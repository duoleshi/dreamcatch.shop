import tkinter as tk
import random
from tkinter import messagebox

class MinesweeperGame:
    def __init__(self, master):
        self.master = master
        self.master.title("Minesweeper 4x4")
        self.master.resizable(False, False)
        
        self.grid_size = 4
        self.num_mines = 3
        self.game_over = False
        
        # Create game variables
        self.grid = []
        self.buttons = []
        self.mines = []
        self.flags = []
        self.opened_cells = 0
        self.total_non_mine_cells = self.grid_size * self.grid_size - self.num_mines
        
        # Create UI elements
        self.create_widgets()
        self.place_mines()
        self.calculate_adjacent_mines()
    
    def create_widgets(self):
        # Create frame for buttons
        self.frame = tk.Frame(self.master)
        self.frame.pack(padx=10, pady=10)
        
        # Create grid of buttons
        for row in range(self.grid_size):
            button_row = []
            grid_row = []
            for col in range(self.grid_size):
                # Create button
                btn = tk.Button(self.frame, width=2, height=1, 
                                command=lambda r=row, c=col: self.click(r, c))
                btn.grid(row=row, column=col)
                btn.bind('<Button-3>', lambda event, r=row, c=col: self.right_click(r, c))
                
                button_row.append(btn)
                grid_row.append(0)  # 0 means no mine
            
            self.buttons.append(button_row)
            self.grid.append(grid_row)
    
    def place_mines(self):
        # Randomly place mines
        mine_count = 0
        while mine_count < self.num_mines:
            row = random.randint(0, self.grid_size - 1)
            col = random.randint(0, self.grid_size - 1)
            
            if self.grid[row][col] != -1:  # -1 means mine
                self.grid[row][col] = -1
                mine_count += 1
    
    def calculate_adjacent_mines(self):
        # Calculate number of adjacent mines for each cell
        for row in range(self.grid_size):
            for col in range(self.grid_size):
                if self.grid[row][col] == -1:  # Skip if cell is a mine
                    continue
                
                # Count adjacent mines
                count = 0
                for r in range(max(0, row-1), min(self.grid_size, row+2)):
                    for c in range(max(0, col-1), min(self.grid_size, col+2)):
                        if self.grid[r][c] == -1:
                            count += 1
                
                self.grid[row][col] = count
    
    def click(self, row, col):
        if self.game_over or (row, col) in self.flags:
            return
        
        # If clicked on a mine
        if self.grid[row][col] == -1:
            self.buttons[row][col].config(text="ðŸ’£", bg="red")
            self.game_over = True
            messagebox.showinfo("Game Over", "You hit a mine! Game Over.")
            self.reveal_all()
            return
        
        # If clicked on a cell with adjacent mines
        if self.grid[row][col] > 0:
            self.buttons[row][col].config(text=str(self.grid[row][col]), 
                                         state=tk.DISABLED, 
                                         disabledforeground="black")
            self.opened_cells += 1
        
        # If clicked on an empty cell
        elif self.grid[row][col] == 0:
            self.reveal_empty_cells(row, col)
        
        # Check if player has won
        if self.opened_cells == self.total_non_mine_cells:
            self.game_over = True
            messagebox.showinfo("Congratulations", "You won the game!")
            self.reveal_all()
    
    def reveal_empty_cells(self, row, col):
        # Skip if cell is already revealed or is a mine
        if self.buttons[row][col]["state"] == tk.DISABLED or self.grid[row][col] == -1:
            return
        
        # Reveal current cell
        if self.grid[row][col] > 0:
            self.buttons[row][col].config(text=str(self.grid[row][col]))
        else:
            self.buttons[row][col].config(text="")
        
        self.buttons[row][col].config(state=tk.DISABLED, relief=tk.SUNKEN)
        self.opened_cells += 1
        
        # If cell is empty, reveal adjacent cells
        if self.grid[row][col] == 0:
            for r in range(max(0, row-1), min(self.grid_size, row+2)):
                for c in range(max(0, col-1), min(self.grid_size, col+2)):
                    if (r, c) != (row, col) and self.buttons[r][c]["state"] != tk.DISABLED:
                        self.reveal_empty_cells(r, c)
    
    def right_click(self, row, col):
        if self.game_over or self.buttons[row][col]["state"] == tk.DISABLED:
            return
        
        if (row, col) in self.flags:
            self.buttons[row][col].config(text="")
            self.flags.remove((row, col))
        else:
            self.buttons[row][col].config(text="ðŸš©")
            self.flags.append((row, col))
        
        return "break"  # Prevent default right-click behavior
    
    def reveal_all(self):
        for row in range(self.grid_size):
            for col in range(self.grid_size):
                if self.grid[row][col] == -1:
                    self.buttons[row][col].config(text="ðŸ’£")
                else:
                    self.buttons[row][col].config(text=str(self.grid[row][col]) if self.grid[row][col] > 0 else "")
                self.buttons[row][col].config(state=tk.DISABLED)

if __name__ == "__main__":
    root = tk.Tk()
    game = MinesweeperGame(root)
    root.mainloop()
